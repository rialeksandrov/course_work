\chapter*{Описание стандартных алгоритмов планирования композитных приложений в распределенной вычислительной среде}
\addcontentsline{toc}{chapter}{1. Описание стандартных алгоритмов планирования композитных приложений в распределенной вычислительной среде}
\begin{spacing}{1.5}

В данной главе рассматриваются классические методы приоритетного планирования. Данные алгоритмы стараются учитывать полную структуру композитного приложения. Их основной идеей является то, что лучшие ресурсы должны быть выделены под задачи, которые оказывают наибольшее влияние на общее время выполнение композитного приложения.  Классическим примером таких алгоритмов является HEFT (Heterogeneous Earliest Finish Time, \cite{HEFT}). Также можно выделить алгоритм DLS (Dynamic Levels Scheduler, \cite{DLS}), который также является удачным развитием данного подхода.



\section*{Алгоритм HEFT}
\addcontentsline{toc}{section}{1.1 Алгоритм HEFT}

Алгоритм HEFT относительно простой и при этом экспериментально эффективный. Его часто берут за эталонный при сравнении по эффективности и скорости составления расписания с новыми алгоритмами. Работу данного алгоритма можно разбить на два этапа --- упорядочивание задач и размещение их на ресурсы.


На первом шаге производится ранжирование задач по следующему признаку:
$$
rank(T_a) = \overline{\mbox{EET}}(T_a) = \max_{T_b \in \text{дочерние задачи $T_a$}}(\overline{\mbox{ECOMT}} (c_{ab}) + rank (T_b))
$$

%rank(Ta) = EET(Ta) + max  ECOMT(cab) + rank(Tb)  Tb∈дочерние задачиTa
Здесь $\overline{\mbox{EET}}(T_a)$ --- средняя оценка времени выполнения задачи $T_a$ по всем ресурсам, $\overline{\mbox{ECOMT}}(c_{ab})$ --- среднее время передачи объема данных $c_{ab}$ между всевозможными парами ресурсов.

Затем все задачи в приложении планируются в неубывающем порядке значения функции $rank(T_a)$. Нельзя не отметить важную особенность функции ранжирования --- родительская задача всегда имеет более высокий приоритет чем ее дочерние задачи. Благодаря такому свойству на момент планирования каждой задачи известно, где будут выполнены все её родительские задачи. Критерием выбора ресурса выполнение является минимизация $ECT$. Таким образом, задачи с большим значением $rank$ получают более производительные ресурсы. Для повышения эффективности используется планирование со вставками. Такое планирование может ставить задачу в любой достаточный для выполнения промежуток свободного времени ресурса. Благодаря этому низкоприоритетная задача может выполниться на ресурсе до высокоприоритетной, пока высокоприоритетная задача ожидает выполнения родительских задач.

Итого, алгоритм $HEFT$ можно представить в следующем виде:


\begin{algorithmic}
\FORALL{$T_a$}
\STATE $rank(T_a) \leftarrow \overline{\mbox{EET}}(T_a) = \max\limits_{T_b \in \text{дочерние задачи $T_a$}}(\overline{\mbox{ECOMT}} (c_{ab}) + rank (T_b))$
\ENDFOR
\STATE $OrderedTasks \leftarrow \text{задачи отсортированные по убыванию $rank_{T_a}$}$
\FORALL{$T \in OrderedTasks$}
\STATE $R \leftarrow arg\min_{R_i} ECT(T, R_i)$
\STATE Запланировать выполнение задачи $T$ на $R$
\ENDFOR
\end{algorithmic}

\newpage
\section*{Алгоритм DLS}
\addcontentsline{toc}{section}{1.2 Алгоритм DLS}

Алгоритм DLS тоже основывается на идеи рангов. Однако, в алгоритме DLS ранг считается для пары --- ресурс, задача. В оригинальной статье этот ранг называются Dynamic Levels, отсюда и название алгоритма. На первом шаге алгоритма для каждой задачи считается SL (SL = Static Level):
$$
SL(T_a) = \overline{\mbox{ EET}}(T_a) + \max_{T_b \in \text{дочерние задачи $T_a$}}(SL (T_b))
$$

Уже на основе посчитанного статического ранга высчитывается Dynamic Level для каждой пары ресурс/задача:
$$
DL(T_a, R_i, Timetable) = SL(T_a) + D(T_a, R_i) - EEST(T_a, R_i, Timetable)
$$
Здесь $SL$ --- Static Level. $D(T_a, R_i)$ --- разница между временем выполнения задачи $T_a$ на ресурсе $R_i$ и на усредненном ресурсе. $EEST(T_a, R_i, Timetable)$ (EEST = Earliest Execution Start Time) наименьшее время, когда задача $T_a$, может начать выполняться на ресурсе $R_i$. Чтобы посчитать $EEST(T_a, R_i, Timetable)$ нужно знать расписание на конкретном ресурсе $R_i$ и знать время конца выполнения всех родительских задач,  отсюда и зависимость от $Timetable$. 

Отличие данного алгоритма от HEFT в том, что ранги высчитываются по мере планирования задач на ресурсы. Об этом и говорит название которое выбрали для ранга --- Dynamic Level. Изначально $DL$ посчитан для всех задач у которых нет зависимостей так как они уже готовы к выполнению. Далее на каждом шагу выбирается пара задача/ресурс которая имеет максимальный $DL$. Данная задача планируется к выполнению на этом ресурсе на минимально возможное время, то есть здесь также используем алгоритм вставок в расписание. Потом $DL$ вычисляется для всех задач у которых стало известно время конца выполнения всех родительских задач.

Весь алгоритм выглядит так:
\begin{algorithmic}
\FORALL{$T_a$}
\STATE $SL(T_a) \leftarrow \overline{\mbox{ EET}}(T_a) + \max\limits_{T_b \in \text{дочерние задачи $T_a$}}(SL (T_b))$
\ENDFOR
\STATE $ReadyToSchedule \leftarrow$ задачи готовые к выполнению
\FORALL{$T_a \in ReadyToSchedule$}
\FORALL{$R_i$}
\STATE $DL(T_a, R_i) \leftarrow SL(T_a) + D(T_a, R_i) - EEST(T_a, R_i)$
\ENDFOR
\ENDFOR

\WHILE{$ReadyToSchedule\neq\varnothing$}
\STATE $R, T \leftarrow arg\max\limits_{T_a \in ReadyToSchedule, R_i} (DL(T_a, R_i))$
\STATE Запланировать выполнение задачи $T$ на $R$
\STATE$ReadyToSchedule \leftarrow ReadyToSchedule - \{R\} $
\STATE $ReadyChilds \leftarrow$  дети задачи $R$ готовые к выполнению
\STATE$ReadyToSchedule \leftarrow ReadyToSchedule \cup ReadyChilds $
\FORALL{$T_a \in ReadyChilds$}
\FORALL{$R_i$}
\STATE $DL(T_a, R_i) \leftarrow SL(T_a) + D(T_a, R_i) - EEST(T_a, R_i)$
\ENDFOR
\ENDFOR
\ENDWHILE
\end{algorithmic}


\end{spacing}